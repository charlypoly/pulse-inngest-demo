"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InngestApi = void 0;
const consts_1 = require("../helpers/consts");
const devserver_1 = require("../helpers/devserver");
const errors_1 = require("../helpers/errors");
const net_1 = require("../helpers/net");
const strings_1 = require("../helpers/strings");
const types_1 = require("../types");
const schema_1 = require("./schema");
class InngestApi {
    constructor({ baseUrl, signingKey, signingKeyFallback, fetch, mode, }) {
        this.apiBaseUrl = baseUrl;
        this.signingKey = signingKey;
        this.signingKeyFallback = signingKeyFallback;
        this.fetch = fetch;
        this.mode = mode;
    }
    get hashedKey() {
        return (0, strings_1.hashSigningKey)(this.signingKey);
    }
    get hashedFallbackKey() {
        if (!this.signingKeyFallback) {
            return;
        }
        return (0, strings_1.hashSigningKey)(this.signingKeyFallback);
    }
    // set the signing key in case it was not instantiated previously
    setSigningKey(key) {
        if (typeof key === "string" && this.signingKey === "") {
            this.signingKey = key;
        }
    }
    setSigningKeyFallback(key) {
        if (typeof key === "string" && !this.signingKeyFallback) {
            this.signingKeyFallback = key;
        }
    }
    async getTargetUrl(path) {
        if (this.apiBaseUrl) {
            return new URL(path, this.apiBaseUrl);
        }
        let url = new URL(path, consts_1.defaultInngestApiBaseUrl);
        if (this.mode.isDev && this.mode.isInferred && !this.apiBaseUrl) {
            const devAvailable = await (0, devserver_1.devServerAvailable)(consts_1.defaultDevServerHost, this.fetch);
            if (devAvailable) {
                url = new URL(path, consts_1.defaultDevServerHost);
            }
        }
        return url;
    }
    async getRunSteps(runId, version) {
        return (0, net_1.fetchWithAuthFallback)({
            authToken: this.hashedKey,
            authTokenFallback: this.hashedFallbackKey,
            fetch: this.fetch,
            url: await this.getTargetUrl(`/v0/runs/${runId}/actions`),
        })
            .then(async (resp) => {
            const data = await resp.json();
            if (resp.ok) {
                return (0, types_1.ok)(schema_1.stepsSchemas[version].parse(data));
            }
            else {
                return (0, types_1.err)(schema_1.errorSchema.parse(data));
            }
        })
            .catch((error) => {
            return (0, types_1.err)({
                error: (0, errors_1.getErrorMessage)(error, "Unknown error retrieving step data"),
                status: 500,
            });
        });
    }
    async getRunBatch(runId) {
        return (0, net_1.fetchWithAuthFallback)({
            authToken: this.hashedKey,
            authTokenFallback: this.hashedFallbackKey,
            fetch: this.fetch,
            url: await this.getTargetUrl(`/v0/runs/${runId}/batch`),
        })
            .then(async (resp) => {
            const data = await resp.json();
            if (resp.ok) {
                return (0, types_1.ok)(schema_1.batchSchema.parse(data));
            }
            else {
                return (0, types_1.err)(schema_1.errorSchema.parse(data));
            }
        })
            .catch((error) => {
            return (0, types_1.err)({
                error: (0, errors_1.getErrorMessage)(error, "Unknown error retrieving event batch"),
                status: 500,
            });
        });
    }
}
exports.InngestApi = InngestApi;
//# sourceMappingURL=api.js.map