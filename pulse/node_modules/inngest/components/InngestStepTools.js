"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.invokePayloadSchema = exports.createStepTools = exports.STEP_INDEXING_SUFFIX = exports.getStepOptions = void 0;
const zod_1 = require("zod");
const consts_1 = require("../helpers/consts");
const strings_1 = require("../helpers/strings");
const types_1 = require("../types");
const InngestFunction_1 = require("./InngestFunction");
const InngestFunctionReference_1 = require("./InngestFunctionReference");
const getStepOptions = (options) => {
    if (typeof options === "string") {
        return { id: options };
    }
    return options;
};
exports.getStepOptions = getStepOptions;
/**
 * Suffix used to namespace steps that are automatically indexed.
 */
exports.STEP_INDEXING_SUFFIX = ":";
/**
 * Create a new set of step function tools ready to be used in a step function.
 * This function should be run and a fresh set of tools provided every time a
 * function is run.
 *
 * An op stack (function state) is passed in as well as some mutable properties
 * that the tools can use to submit a new op.
 */
const createStepTools = (client, execution, stepHandler) => {
    /**
     * A local helper used to create tools that can be used to submit an op.
     *
     * When using this function, a generic type should be provided which is the
     * function signature exposed to the user.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const createTool = (
    /**
     * A function that returns an ID for this op. This is used to ensure that
     * the op stack is correctly filled, submitted, and retrieved with the same
     * ID.
     *
     * It is passed the arguments passed by the user.
     *
     * Most simple tools will likely only need to define this.
     */
    matchOp, opts) => {
        return (async (...args) => {
            const parsedArgs = args;
            return stepHandler({ args: parsedArgs, matchOp, opts });
        });
    };
    /**
     * Define the set of tools the user has access to for their step functions.
     *
     * Each key is the function name and is expected to run `createTool` and pass
     * a generic type for that function as it will appear in the user's code.
     */
    const tools = {
        /**
         * Send one or many events to Inngest. Should always be used in place of
         * `inngest.send()` to ensure that the event send is successfully retried
         * and not sent multiple times due to memoisation.
         *
         * @example
         * ```ts
         * await step.sendEvent("emit-user-creation", {
         *   name: "app/user.created",
         *   data: { id: 123 },
         * });
         *
         * await step.sendEvent("emit-user-updates", [
         *   {
         *     name: "app/user.created",
         *     data: { id: 123 },
         *   },
         *   {
         *     name: "app/user.feed.created",
         *     data: { id: 123 },
         *   },
         * ]);
         * ```
         *
         * Returns a promise that will resolve once the event has been sent.
         */
        sendEvent: createTool(({ id, name }) => {
            return {
                id,
                op: types_1.StepOpCode.StepPlanned,
                name: "sendEvent",
                displayName: name !== null && name !== void 0 ? name : id,
            };
        }, {
            fn: (idOrOptions, payload) => {
                return client["_send"]({
                    payload,
                    headers: execution["options"]["headers"],
                });
            },
        }),
        /**
         * Wait for a particular event to be received before continuing. When the
         * event is received, it will be returned.
         *
         * You can also provide options to control the particular event that is
         * received, for example to ensure that a user ID matches between two
         * events, or to only wait a maximum amount of time before giving up and
         * returning `null` instead of any event data.
         */
        waitForEvent: createTool(({ id, name }, 
        /**
         * Options to control the event we're waiting for.
         */
        opts) => {
            const matchOpts = {
                timeout: (0, strings_1.timeStr)(typeof opts === "string" ? opts : opts.timeout),
            };
            if (typeof opts !== "string") {
                if (opts === null || opts === void 0 ? void 0 : opts.match) {
                    matchOpts.if = `event.${opts.match} == async.${opts.match}`;
                }
                else if (opts === null || opts === void 0 ? void 0 : opts.if) {
                    matchOpts.if = opts.if;
                }
            }
            return {
                id,
                op: types_1.StepOpCode.WaitForEvent,
                name: opts.event,
                opts: matchOpts,
                displayName: name !== null && name !== void 0 ? name : id,
            };
        }),
        /**
         * Use this tool to run business logic. Each call to `run` will be retried
         * individually, meaning you can compose complex workflows that safely
         * retry dependent asynchronous actions.
         *
         * The function you pass to `run` will be called only when this "step" is to
         * be executed and can be synchronous or asynchronous.
         *
         * In either case, the return value of the function will be the return value
         * of the `run` tool, meaning you can return and reason about return data
         * for next steps.
         */
        run: createTool(({ id, name }) => {
            return {
                id,
                op: types_1.StepOpCode.StepPlanned,
                name: id,
                displayName: name !== null && name !== void 0 ? name : id,
            };
        }, { fn: (stepOptions, fn) => fn() }),
        /**
         * Wait a specified amount of time before continuing.
         *
         * The time to wait can be specified using a `number` of milliseconds or an
         * `ms`-compatible time string like `"1 hour"`, `"30 mins"`, or `"2.5d"`.
         *
         * {@link https://npm.im/ms}
         *
         * To wait until a particular date, use `sleepUntil` instead.
         */
        sleep: createTool(({ id, name }, time) => {
            /**
             * The presence of this operation in the returned stack indicates that the
             * sleep is over and we should continue execution.
             */
            return {
                id,
                op: types_1.StepOpCode.Sleep,
                name: (0, strings_1.timeStr)(time),
                displayName: name !== null && name !== void 0 ? name : id,
            };
        }),
        /**
         * Wait until a particular date before continuing by passing a `Date`.
         *
         * To wait for a particular amount of time from now, always use `sleep`
         * instead.
         */
        sleepUntil: createTool(({ id, name }, time) => {
            const date = typeof time === "string" ? new Date(time) : time;
            /**
             * The presence of this operation in the returned stack indicates that the
             * sleep is over and we should continue execution.
             */
            try {
                return {
                    id,
                    op: types_1.StepOpCode.Sleep,
                    name: date.toISOString(),
                    displayName: name !== null && name !== void 0 ? name : id,
                };
            }
            catch (err) {
                /**
                 * If we're here, it's because the date is invalid. We'll throw a custom
                 * error here to standardise this response.
                 */
                // TODO PrettyError
                console.warn("Invalid date or date string passed to sleepUntil;", err);
                // TODO PrettyError
                throw new Error(`Invalid date or date string passed to sleepUntil: ${time.toString()}`);
            }
        }),
        /**
         * Invoke a passed Inngest `function` with the given `data`. Returns the
         * result of the returned value of the function or `null` if the function
         * does not return a value.
         *
         * A string ID can also be passed to reference functions outside of the
         * current app.
         */
        invoke: createTool(({ id, name }, invokeOpts) => {
            // Create a discriminated union to operate on based on the input types
            // available for this tool.
            const optsSchema = exports.invokePayloadSchema.extend({
                timeout: zod_1.z.union([zod_1.z.number(), zod_1.z.string(), zod_1.z.date()]).optional(),
            });
            const parsedFnOpts = optsSchema
                .extend({
                _type: zod_1.z.literal("fullId").optional().default("fullId"),
                function: zod_1.z.string().min(1),
            })
                .or(optsSchema.extend({
                _type: zod_1.z.literal("fnInstance").optional().default("fnInstance"),
                function: zod_1.z.instanceof(InngestFunction_1.InngestFunction),
            }))
                .or(optsSchema.extend({
                _type: zod_1.z.literal("refInstance").optional().default("refInstance"),
                function: zod_1.z.instanceof(InngestFunctionReference_1.InngestFunctionReference),
            }))
                .safeParse(invokeOpts);
            if (!parsedFnOpts.success) {
                throw new Error(`Invalid invocation options passed to invoke; must include either a function or functionId.`);
            }
            const { _type, function: fn, data, user, v, timeout } = parsedFnOpts.data;
            const payload = { data, user, v };
            const opts = {
                payload,
                function_id: "",
                timeout: typeof timeout === "undefined" ? undefined : (0, strings_1.timeStr)(timeout),
            };
            switch (_type) {
                case "fnInstance":
                    opts.function_id = fn.id(fn["client"].id);
                    break;
                case "fullId":
                    console.warn(`${consts_1.logPrefix} Invoking function with \`function: string\` is deprecated and will be removed in v4.0.0; use an imported function or \`referenceFunction()\` instead. See https://innge.st/ts-referencing-functions`);
                    opts.function_id = fn;
                    break;
                case "refInstance":
                    opts.function_id = [fn.opts.appId || client.id, fn.opts.functionId]
                        .filter(Boolean)
                        .join("-");
                    break;
            }
            return {
                id,
                op: types_1.StepOpCode.InvokeFunction,
                displayName: name !== null && name !== void 0 ? name : id,
                opts,
            };
        }),
    };
    return tools;
};
exports.createStepTools = createStepTools;
/**
 * The event payload portion of the options for `step.invoke()`. This does not
 * include non-payload options like `timeout` or the function to invoke.
 */
exports.invokePayloadSchema = zod_1.z.object({
    data: zod_1.z.record(zod_1.z.any()).optional(),
    user: zod_1.z.record(zod_1.z.any()).optional(),
    v: zod_1.z.string().optional(),
});
//# sourceMappingURL=InngestStepTools.js.map