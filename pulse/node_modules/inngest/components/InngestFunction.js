"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InngestFunction = void 0;
const consts_1 = require("../helpers/consts");
const strings_1 = require("../helpers/strings");
const InngestExecution_1 = require("./execution/InngestExecution");
const v0_1 = require("./execution/v0");
const v1_1 = require("./execution/v1");
/**
 * A stateless Inngest function, wrapping up function configuration and any
 * in-memory steps to run when triggered.
 *
 * This function can be "registered" to create a handler that Inngest can
 * trigger remotely.
 *
 * @public
 */
class InngestFunction {
    /**
     * A stateless Inngest function, wrapping up function configuration and any
     * in-memory steps to run when triggered.
     *
     * This function can be "registered" to create a handler that Inngest can
     * trigger remotely.
     */
    constructor(client, 
    /**
     * Options
     */
    opts, fn) {
        this.client = client;
        this.opts = opts;
        this.fn = fn;
        this.onFailureFn = this.opts.onFailure;
        this.middleware = this.client["initializeMiddleware"](this.opts.middleware, { registerInput: { fn: this }, prefixStack: this.client["middleware"] });
    }
    /**
     * The generated or given ID for this function.
     */
    id(prefix) {
        return [prefix, this.opts.id].filter(Boolean).join("-");
    }
    /**
     * The name of this function as it will appear in the Inngest Cloud UI.
     */
    get name() {
        return this.opts.name || this.id();
    }
    /**
     * Retrieve the Inngest config for this function.
     */
    getConfig(
    /**
     * Must be provided a URL that will be used to access the function and step.
     * This function can't be expected to know how it will be accessed, so
     * relies on an outside method providing context.
     */
    baseUrl, appPrefix) {
        var _a, _b;
        const fnId = this.id(appPrefix);
        const stepUrl = new URL(baseUrl.href);
        stepUrl.searchParams.set(consts_1.queryKeys.FnId, fnId);
        stepUrl.searchParams.set(consts_1.queryKeys.StepId, InngestFunction.stepId);
        const { retries: attempts, cancelOn, idempotency, batchEvents, rateLimit, throttle, concurrency, debounce, priority, } = this.opts;
        /**
         * Convert retries into the format required when defining function
         * configuration.
         */
        const retries = typeof attempts === "undefined" ? undefined : { attempts };
        const fn = {
            id: fnId,
            name: this.name,
            triggers: ((_a = this.opts.triggers) !== null && _a !== void 0 ? _a : []).map((trigger) => {
                if ("event" in trigger) {
                    return {
                        event: trigger.event,
                        expression: trigger.if,
                    };
                }
                return {
                    cron: trigger.cron,
                };
            }),
            steps: {
                [InngestFunction.stepId]: {
                    id: InngestFunction.stepId,
                    name: InngestFunction.stepId,
                    runtime: {
                        type: "http",
                        url: stepUrl.href,
                    },
                    retries,
                },
            },
            idempotency,
            batchEvents,
            rateLimit,
            throttle,
            concurrency,
            debounce,
            priority,
        };
        if (cancelOn) {
            fn.cancel = cancelOn.map(({ event, timeout, if: ifStr, match }) => {
                const ret = {
                    event,
                };
                if (timeout) {
                    ret.timeout = (0, strings_1.timeStr)(timeout);
                }
                if (match) {
                    ret.if = `event.${match} == async.${match}`;
                }
                else if (ifStr) {
                    ret.if = ifStr;
                }
                return ret;
            }, []);
        }
        const config = [fn];
        if (this.onFailureFn) {
            const id = `${fn.id}${InngestFunction.failureSuffix}`;
            const name = `${(_b = fn.name) !== null && _b !== void 0 ? _b : fn.id} (failure)`;
            const failureStepUrl = new URL(stepUrl.href);
            failureStepUrl.searchParams.set(consts_1.queryKeys.FnId, id);
            config.push({
                id,
                name,
                triggers: [
                    {
                        event: consts_1.internalEvents.FunctionFailed,
                        expression: `event.data.function_id == '${fnId}'`,
                    },
                ],
                steps: {
                    [InngestFunction.stepId]: {
                        id: InngestFunction.stepId,
                        name: InngestFunction.stepId,
                        runtime: {
                            type: "http",
                            url: failureStepUrl.href,
                        },
                        retries: { attempts: 1 },
                    },
                },
            });
        }
        return config;
    }
    createExecution(opts) {
        const options = Object.assign({ client: this.client, fn: this }, opts.partialOptions);
        const versionHandlers = {
            [InngestExecution_1.ExecutionVersion.V1]: () => (0, v1_1.createV1InngestExecution)(options),
            [InngestExecution_1.ExecutionVersion.V0]: () => (0, v0_1.createV0InngestExecution)(options),
        };
        return versionHandlers[opts.version]();
    }
}
exports.InngestFunction = InngestFunction;
InngestFunction.stepId = "step";
InngestFunction.failureSuffix = "-failure";
//# sourceMappingURL=InngestFunction.js.map